CSSS 508, Week 6
===
author: Rebecca Ferrell
date: May 4, 2016
transition: rotate
width: 1100
height: 750


Goofus approach to repetitive data analysis
===
incremental: true

```{r set-options, echo=FALSE, cache=FALSE}
options(width = 120)
```

![Goofus and Gallant](http://the-toast.net/wp-content/uploads/2014/09/Goofus.jpg)

```{r goofus}
mean1 <- mean(swiss$Fertility)
mean2 <- mean(swiss$Agriculture)
mean3 <- mean(swiss$Examination)
mean4 <- mean(swiss$Fertility)
mean5 <- mean(swiss$Catholic)
mean5 <- mean(swiss$Infant.Mortality)
```


Gallant: Don't Repeat Yourself (DRY)
===
incremental: true

Want to avoid repetition and inconsistencies when:

* For each item in a list, doing the same thing to it
* Partitioning data, fitting same model to each part separately
* Studying behavior of models under many different samples of data
* Importing many similar data files, cleaning up each, gluing them together

Things to identify:

1. What we're looping over
2. What we do in the loop
3. Is what happens in the loop affected by previous iterations?


Programming agenda 
===

**Today:**

* `dplyr` and `broom`
* `for` and `while` loop programming (most general method)
* Vectorization to avoid loops

**Next week:**

* Writing your own functions!
* `dplyr::summarize_each`, `dplyr::mutate_each`
* `lapply`, `replicate`
* `apply`


Looping dplyr-style
===
type: section


Motivating example
===

We will model life expectancy as a function of time within each country in the `gapminder` data. Start with some exploratory data analysis by sampling 20 countries and looking at trends:

```{r warning=FALSE, message=FALSE}
library(gapminder)
library(dplyr)
library(ggplot2)
set.seed(1234)
(rando_countries <- sample(unique(gapminder$country), size = 20, replace = FALSE))
```


Life expectancy trends in sample
===

```{r, fig.width = 10, fig.height = 4, dpi=300, out.width="1100px", out.height="440px"}
ggplot(gapminder %>% filter(country %in% rando_countries), aes(x = year, y = lifeExp, group = country)) + geom_line() + geom_smooth(method = "lm", size = 0.5) + facet_wrap( ~ country, nrow = 4)
```


Modeling approach
===

Based on the plot, modeling life expectancy as a linear function of time is a reasonable starting point.

Some countries have much steeper trajectories than others (more improvement in life expectancy). Let's fit a linear regression of life expectancy on time *for each country separately* so we get an intercept and slope per country.

First: re-define time as years since 1980 for easier interpretation of the regression intercepts (i.e. predicted life expectancy in 1980).
```{r}
gapminder <- gapminder %>%
    mutate(time_1980 = year - 1980)
```


dplyr::do()
===

When the loop involves taking different chunks of your data and taking the same actions on it, the `do` function in the `dplyr` package combined with `group_by` is a good option.

```{r, cache=TRUE}
gapminder_new <- gapminder %>%
    group_by(country, continent) %>%
    do(time_trend = lm(lifeExp ~ time_1980, data = .))
```

Comments:

* We are grouping by *both* country and continent. Continent is extraneous (each country belongs to one continent), but grouping keeps the variable `continent` on the data and avoids an extra join.
* The period `.` means "this is where the stuff before the pipe goes in". We haven't been using it much because with `dplyr` functions, data is the first argument.


lm output with do
===

```{r}
head(gapminder_new, 2)
```

The data are not "tidy" yet: our model information is all stuck in an `lm` object in the `time_trend` column. We want to pull out for each country:

* Intercept
* Slope (mean change in life expectancy per year)
* $R^2$ (proportion of variance in life expectancy explained by time)


broom
===

We'll use the `broom` package, which is designed to tidy up `do` output of statistical functions. Install and load `broom`.
```{r}
# install.packages("broom")
library(broom)
```

`broom` has three key functions that work across a wide array of statistical models:

* `glance`: a single row summary of model fit ($R^2$, etc.)
* `tidy`: a tidy representation of a model (coefficients, SEs)
* `augment`: adds columns with predictions, residuals, etc.


glance
===

`broom`'s `glance` function gets some model summaries:

```{r glance, cache=TRUE}
gapminder_glance <- gapminder_new %>%
    glance(time_trend)
head(gapminder_glance, 2)
```


tidy
===

`broom`'s `tidy` function extracts coefficients, standard errors, and confidence intervals in tidy format (one row per parameter):

```{r tidy, cache=TRUE}
gapminder_tidy <- gapminder_new %>%
    tidy(time_trend, conf.int = TRUE)
head(gapminder_tidy, 4)
```


Un-tidying tidy
===

In this case, the data are maybe *too* tidy: we want the coefficients and to have them on the same row. Use `tidyr`'s `spread` from last week to modify:

```{r tidying_tidy, cache=TRUE}
library(tidyr)
gapminder_tidy2 <- gapminder_tidy %>%
    select(country, continent, term, estimate) %>%
    spread(key = term, value = estimate)
head(gapminder_tidy2, 3)
```



augment
===

`broom`'s `augment` function could get residuals for each observation if we want:

```{r augment, cache=TRUE}
gapminder_augment <- gapminder_new %>%
    augment(time_trend)
head(gapminder_augment, 2)
```


Combining
===

Use `left_join` to merge everything of interest:

```{r joining, cache=TRUE}
gapminder_lm_final <- gapminder_tidy2 %>%
    # merge on R^2 from the glance file:
    left_join(gapminder_glance %>%
                  ungroup() %>% # removes by-continent grouping
                  # (so that continent doesn't appear twice)
                  select(country, r.squared),
              by = "country")
head(gapminder_lm_final, 3)
```


Possibilities
===

With `gapminder_lm_final`, we can now easily examine:

* Fitted life expectancies in 1980 across countries
* Rate of average life expectancy gains during period across countries
* Countries for which the linear trend fit well (high $R^2$) or didn't (low $R^2$)

Had we kept other variables around, there are many other things we could look at, like regression residual diagnostics.


Example: average gains by continent
===

To make a density plot of average annual life expectancy gains by continent:
```{r}
lifeExp_gains <- ggplot(data = gapminder_lm_final,
       aes(x = time_1980,
           fill = continent)) +
    geom_density() +
    geom_vline(xintercept = 0, size = 2) + 
    facet_wrap( ~ continent, scales = "free_y") +
    xlab("Annual life expectancy gain within country (years)") +
    ggtitle("Country-level average annual life expectancy gains, 1952-2007") +
    theme_minimal() +
    theme(legend.position = "none") # no legend
```


Average gains by continent plot
===

```{r, echo=FALSE, fig.width = 10, fig.height = 5, dpi=300, out.width="1100px", out.height="550px"}
lifeExp_gains
```


for loops
===
type: section


for loops
===
incremental: true

`for` loops are the most general kind of loop. You provide a vector, and inside the loop, it assigns the first value to some variable, does stuff, increments the variable to the next value, and keeps going until it runs out of values.

```{r}
for(i in 1:3) {
    # inside for, output won't show up w/o "print"
    print(i^2) 
}
```

Iterating over indices `1:n` is very common. `n` might be a vector length or number of rows/columns in matrix or data frame.


Iterate over character vectors
===
incremental: true

You can also iterate over a character vector:
```{r}
some_letters <- letters[4:6]
for(i in some_letters) {
    print(i)
}
i # the index variable was added to environment
```


seq_along
===
incremental: true

When you want to loop over something that isn't numeric but want to have a numeric index of where you are in the loop, `seq_along` is useful:

```{r}
for(a in seq_along(some_letters)) {
    print(paste0("Letter ", a, ": ", some_letters[a]))
}
a
```


Pre-allocation
===
incremental: true

Usually in a `for` loop, you aren't printing output, but want to store results from each iteration somewhere. Figure out how you want to store the output (vector, matrix, data frame, list, etc.) and then **pre-allocate** an object of the right size for that (typically with zeroes or missing values as placeholders).

```{r}
# preallocate numeric vector
iters <- 5
output <- numeric(iters)

for(i in 1:iters) {
    output[i] <- (i-1)^2 + (i-2)^2
}
output
```


Preallocated list: regression models
===
incremental: true

```{r}
x <- rnorm(30) # making fake data
fake_data <- data.frame(x = x, y = 2 * x + rnorm(30))
# model formulas as strings in named vector
models <- c("int only" = "y ~ 1", "standard" = "y ~ x", "quadratic" = "y ~ x + I(x^2)")
output <- vector("list", length(models)) # initialize list
names(output) <- names(models) # give entries good names
# fit each model to fake_data and store in output
for(mod in names(models)) {
    output[[mod]] <- lm(formula(models[mod]),
                        data = fake_data)
}
str(output)
```


Conditional flow
===
type: section

if, else
===
type: incremental

You've seen `ifelse` before for logical checks on a whole vector. For checking whether a single logical statement holds and then conditionally executing a set of actions, use `if()` and `else`:

```{r, eval=FALSE}
for(i in 1:10) {
    if(i %% 2 == 0) {
        print(paste0("The number ", i, " is even"))
    } else if(i %% 3 == 0) {
        print(paste0("The number ", i, " is divisible by 3"))
    } else {
        print(paste0("The number ", i, " is not divisible by 2 or 3"))
    }
}
```

**Warning!** `else` needs to be on same line as the closing brace `}` of previous `if()`.


if, else: example from previous slide
===
incremental: true

```{r, echo=FALSE}
for(i in 1:10) {
    if(i %% 2 == 0) {
        print(paste0("The number ", i, " is even"))
    } else if(i %% 3 == 0) {
        print(paste0("The number ", i, " is not even but divisible by 3"))
    } else {
        print(paste0("The number ", i, " is not divisible by 2 or 3"))
    }
}
```


while loops
===
incremental: true

Another looping structure is the `while` loop. Rather than iterating over a predefined vector, the loop keeps going until some condition is no longer true.

```{r}
num_heads <- 0; num_flips <- 0
while(num_heads < 4) {
    coin_flip <- rbinom(n = 1, size = 1, prob = 0.5)
    if(coin_flip == 1) { num_heads <- num_heads + 1 }
    num_flips <- num_flips + 1
}
num_flips # follows negative binomial distribution
```


Difficult real-world example
===
type: section

Importing many files
===

Let us journey into...**data hell!**

![Garden of Earthly Delights](https://upload.wikimedia.org/wikipedia/commons/f/f6/Mad_meg.jpg)

[California Office of Statewide Health Planning and Development Hospital Quarterly Financial and Utilization Data Files](http://oshpd.ca.gov/hid/Products/Hospitals/QuatrlyFinanData/CmpleteData/default.asp)


Data prep sketch outline
===
incremental: true

- Pre-allocate a list for the individual files
- Inside a `for` loop `seq_along`ing the file names:
    + Make a URL and download file 
    + Read the file in with Excel-reading package and store in list
- Use `dplyr::bind_rows` to combine all tables into one
- Remove the list to save memory
- Clean up the combined data
- Some variations on general process you might encounter:
    + Unzip files first (`unzip`)
    + Use `if` logic to clean up data differently depending on file
- **HOMEWORK**: read the [extended writeup on the course page](https://rebeccaferrell.github.io/Lectures/data_download_demo.html).


Vectorization
===
type: section

Non-vectorized example
===

We have a vector of numbers, and we want to add 1 to each element.
```{r}
my_vector <- rnorm(100000)
```

A `for` loop approach works but is slow:
```{r}
for_start <- proc.time() # start the clock
new_vector <- rep(NA, length(my_vector))
for(position in 1:length(my_vector)) {
    new_vector[position] <- my_vector[position] + 1
}
(for_time <- proc.time() - for_start) # time elapsed
```


Vectorization wins
===

Recognize that we can instead use R's vector addition (with recycling):
```{r}
vec_start <- proc.time()
new_vector <- my_vector + 1
(vec_time <- proc.time() - vec_start)
for_time / vec_time
```

Vector/matrix arithmetic is implemented using fast, optimized functions that a `for` loop can't compete with.


Vectorization examples
===
incremental: true

* `rowSums`, `colSums`, `rowMeans`, `colMeans` give sums or averages over rows or columns of matrices/data frames

```{r}
(a_matrix <- matrix(1:12, nrow = 3, ncol = 4))
rowSums(a_matrix)
```


More vectorization examples
===
incremental: true

* `cumsum`, `cumprod`, `cummin`, `cummax` give back a vector with cumulative quantities (e.g. running totals)
```{r}
cumsum(1:7)
```

* `pmax` and `pmin` take a matrix or set of vectors, output the min or max for each **p**osition (after recycling):
```{r}
pmax(c(0, 2, 4), c(1, 1, 1), c(2, 2, 2))
```


Homework
===
type: section

Read the [data downloading demonstration on the course page](https://rebeccaferrell.github.io/Lectures/data_download_demo.html). I hope that your forays into automated data downloading and cleaning are smoother than this one was!

Reminder that HW 5 assigned last week is still due next week.