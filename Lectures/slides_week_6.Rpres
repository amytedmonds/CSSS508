CSSS 508, Week 6
===
author: Rebecca Ferrell
date: May 4, 2016
transition: rotate
width: 1100
height: 750


Goofus approach to repetitive data analysis
===
incremental: true

```{r set-options, echo=FALSE, cache=FALSE}
options(width = 120)
```

![Goofus and Gallant](http://the-toast.net/wp-content/uploads/2014/09/Goofus.jpg)

```{r goofus}
mean1 <- mean(swiss$Fertility)
mean2 <- mean(swiss$Agriculture)
mean3 <- mean(swiss$Examination)
mean4 <- mean(swiss$Fertility)
mean5 <- mean(swiss$Catholic)
mean5 <- mean(swiss$Infant.Mortality)
```


Gallant: Don't Repeat Yourself (DRY)!
===
incremental: true

We want to avoid manual repetition and inconsistencies when we do the same thing over and over. Telling code to repeat tasks for us through *looping* prevents human-introduced errors.

Things to identify that inform how we loop:

1. What we're looping over 
2. What we do inside each iteration of the loop
3. Is what happens in the loop affected by previous iterations?


Programming and looping agenda 
===

**Today:**

* `for` and `while` loop programming (most general method)
* Vectorization to avoid loops

**Next week:**

* Writing your own functions!
* Looping methods that like your special functions


for loops
===
type: section


for loops
===
incremental: true

`for` loops are the most general kind of loop. You provide a vector, and inside the loop, it assigns the first value to some variable, does stuff, increments the variable to the next value, and keeps going until it runs out of values.

```{r}
for(i in 1:3) {
    # inside for, output won't show up w/o "print"
    print(i^2) 
}
```

Iterating over indices `1:n` is very common. `n` might be a vector length or number of rows/columns in matrix or data frame.


Iterate over character vectors
===
incremental: true

You can also iterate over a character vector:
```{r}
some_letters <- letters[4:6]
for(i in some_letters) {
    print(i)
}
i # the index variable was added to environment
```


seq_along
===
incremental: true

When you want to loop over something that isn't numeric but want to have a numeric index of where you are in the loop, `seq_along` is useful:

```{r}
for(a in seq_along(some_letters)) {
    print(paste0("Letter ", a, ": ", some_letters[a]))
}
a
```


Pre-allocation
===
incremental: true

Usually in a `for` loop, you aren't printing output, but want to store results from each iteration somewhere. Figure out how you want to store the output (vector, matrix, data frame, list, etc.) and then **pre-allocate** an object of the right size for that (typically with zeroes or missing values as placeholders).

```{r}
# preallocate numeric vector
iters <- 5
output <- numeric(iters)

for(i in 1:iters) {
    output[i] <- (i-1)^2 + (i-2)^2
}
output
```


Preallocated list: regression models
===
incremental: true

```{r}
x <- rnorm(30) # making fake data
fake_data <- data.frame(x = x, y = 2 * x + rnorm(30))
# model formulas as strings in named vector
models <- c("int only" = "y ~ 1", "standard" = "y ~ x", "quadratic" = "y ~ x + I(x^2)")
output <- vector("list", length(models)) # initialize list
names(output) <- names(models) # give entries good names
# fit each model to fake_data and store in output
for(mod in names(models)) {
    output[[mod]] <- lm(formula(models[mod]),
                        data = fake_data)
}
str(output)
```


Conditional flow
===
type: section

if, else
===
type: incremental

You've seen `ifelse` before for logical checks on a whole vector. For checking whether a single logical statement holds and then conditionally executing a set of actions, use `if()` and `else`:

```{r, eval=FALSE}
for(i in 1:10) {
    if(i %% 2 == 0) {
        print(paste0("The number ", i, " is even"))
    } else if(i %% 3 == 0) {
        print(paste0("The number ", i, " is divisible by 3"))
    } else {
        print(paste0("The number ", i, " is not divisible by 2 or 3"))
    }
}
```

**Warning!** `else` needs to be on same line as the closing brace `}` of previous `if()`.


if, else: example from previous slide
===
incremental: true

```{r, echo=FALSE}
for(i in 1:10) {
    if(i %% 2 == 0) {
        print(paste0("The number ", i, " is even"))
    } else if(i %% 3 == 0) {
        print(paste0("The number ", i, " is not even but divisible by 3"))
    } else {
        print(paste0("The number ", i, " is not divisible by 2 or 3"))
    }
}
```


while loops
===
incremental: true

Another looping structure is the `while` loop. Rather than iterating over a predefined vector, the loop keeps going until some condition is no longer true.

```{r}
num_heads <- 0; num_flips <- 0
while(num_heads < 4) {
    coin_flip <- rbinom(n = 1, size = 1, prob = 0.5)
    if(coin_flip == 1) { num_heads <- num_heads + 1 }
    num_flips <- num_flips + 1
}
num_flips # follows negative binomial distribution
```


Difficult real-world example
===
type: section

Importing many files
===

Let us journey into...**data hell!**

![Garden of Earthly Delights](https://upload.wikimedia.org/wikipedia/commons/f/f6/Mad_meg.jpg)

[California Office of Statewide Health Planning and Development Hospital Quarterly Financial and Utilization Data Files](http://oshpd.ca.gov/hid/Products/Hospitals/QuatrlyFinanData/CmpleteData/default.asp)


Data prep sketch outline
===
incremental: true

- Pre-allocate a list for the individual files
- Inside a `for` loop `seq_along`ing the file names:
    + Make a URL and download file 
    + Read the file in with Excel-reading package and store in list
- Combine the data for each year into one file
- Clean up the combined data
- Some variations on general process you might encounter:
    + Unzip files first (`unzip`)
    + Use `if` logic to clean up data differently depending on file
- **HOMEWORK**: read the [extended writeup on the course page](https://rebeccaferrell.github.io/Lectures/data_download_demo.html).


Vectorization
===
type: section

Non-vectorized example
===

We have a vector of numbers, and we want to add 1 to each element.
```{r}
my_vector <- rnorm(100000)
```

A `for` loop approach works but is slow:
```{r}
for_start <- proc.time() # start the clock
new_vector <- rep(NA, length(my_vector))
for(position in 1:length(my_vector)) {
    new_vector[position] <- my_vector[position] + 1
}
(for_time <- proc.time() - for_start) # time elapsed
```


Vectorization wins
===

Recognize that we can instead use R's vector addition (with recycling):
```{r}
vec_start <- proc.time()
new_vector <- my_vector + 1
(vec_time <- proc.time() - vec_start)
for_time / vec_time
```

Vector/matrix arithmetic is implemented using fast, optimized functions that a `for` loop can't compete with.


Vectorization examples
===
incremental: true

* `rowSums`, `colSums`, `rowMeans`, `colMeans` give sums or averages over rows or columns of matrices/data frames

```{r}
(a_matrix <- matrix(1:12, nrow = 3, ncol = 4))
rowSums(a_matrix)
```


More vectorization examples
===
incremental: true

* `cumsum`, `cumprod`, `cummin`, `cummax` give back a vector with cumulative quantities (e.g. running totals)
```{r}
cumsum(1:7)
```

* `pmax` and `pmin` take a matrix or set of vectors, output the min or max for each **p**osition (after recycling):
```{r}
pmax(c(0, 2, 4), c(1, 1, 1), c(2, 2, 2))
```


Homework
===
type: section

Read the [data downloading demonstration on the course page](https://rebeccaferrell.github.io/Lectures/data_download_demo.html). I hope that your forays into automated data downloading and cleaning are smoother than this one was!

Reminder: HW 5 assigned last week is due next week.